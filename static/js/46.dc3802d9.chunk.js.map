{"version":3,"file":"static/js/46.dc3802d9.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/createClass.js","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","Vector2D.ts","gencode/ConvertedData.ts","gencode/Results.ts","gencode/GenCode.ts"],"sourcesContent":["function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","export default class Vector2D {\n    x: number;\n    y: number;\n    constructor(x: number, y: number) {\n        this.x = x;\n        this.y = y;\n    }\n}\n","import Color from \"../Color\";\nimport IWorkerMessage from \"../IWorkerMessage\";\n\nexport default class ConvertedData implements IWorkerMessage {\n  constructor(public convertedData: Uint32Array, public index: number, public layer: number, public color: Color) {}\n  getTransfer(): Transferable[] {\n      return [ this.convertedData.buffer ];\n  }\n}","import IWorkerMessage from \"../IWorkerMessage\";\n\nexport default class Results implements IWorkerMessage {\n  constructor(public progress: number, public working: boolean, public result: undefined | IWorkerMessage) {};\n  getTransfer(): Transferable[] {\n    if (this.result !== undefined) {\n      return this.result.getTransfer();\n    } else {\n      return [];\n    }\n  }\n}","import PictureData from '../PictureData';\nimport Vector2D from '../Vector2D';\nimport ConvertCommands from './ConvertCommand';\nimport ConvertedData from './ConvertedData';\nimport Results from './Results';\n\nexport default {}\n\n// eslint-disable-next-line\nconst ctx: Worker = self as any;\n\n// 送れるメッセージの種類：変換開始\n// 返すメッセージの種類：変換後データ(1カラーレイヤーごとに渡す)\nctx.addEventListener('message', (evt: MessageEvent<ConvertCommands>) => {\n  let d = evt.data;\n  const vCount = Math.floor(d.pictureHeight / d.cropHeight);\n  const hCount = Math.floor(d.pictureWidth / d.cropWidth);\n  const phase = hCount * vCount * d.colorSet.length;\n\n  const pic = d.pictureData.map((v) => d.orderTable[v]);\n  ctx.postMessage(new Results(1 / phase, true, undefined));\n\n  for (let x = 0; x < hCount; x++) {\n    for (let y = 0; y < vCount; y++) {\n      for (let l = 0; l < d.colorSet.length; l++) {\n        let picIndex = d.orderTable.indexOf(l);\n        ctx.postMessage(new Results(\n          (((x * vCount) + y) * d.colorSet.length + l + 1) / phase, true,\n          new ConvertedData(\n            (d.drawFlagTable[picIndex]) ?\n            new Uint32Array() :\n            convertLayer(pic,\n              d.pictureWidth, d.pictureHeight,\n              d.cropHeight, d.cropHeight,\n              x * d.cropWidth, y * d.cropHeight, l),\n            y + vCount * x, l, d.colorSet[picIndex])\n        ));\n      }\n    }\n  }\n  ctx.postMessage(new Results(1, false, undefined));\n});\n\nfunction convertLayer(picture: Uint32Array, w: number, h: number, cw: number, ch: number, offsetX: number, offsetY: number, targetColor: number) {\n  const indexer = makeIndexer(w, h, offsetX, offsetY);\n  const indexerZ = makeIndexer(cw, ch, 0, 0);\n  const rectangleMatrix = new Array<Array<Vector2D>>(ch * cw);\n  const drawCodes = Array<number>();\n\n  for (let y = 0; y < ch; y++) {\n    for (let x = 0; x < cw; x++) {\n      rectangleMatrix[indexerZ(x, y)] = new Array<Vector2D>();\n    }\n  }\n\n  for (let y = 0; y < ch; y++) {\n    for (let x = 0; x < cw; x++) {\n      const f: boolean =\n        (picture[indexer(x, y)] <= targetColor)\n        && ((x === 0 || picture[indexer(x - 1, y)] > targetColor)\n          || (y === 0 || picture[indexer(x, y - 1)] > targetColor));\n      if (f) {\n        let tx: number, ty: number, ox!: number | undefined;\n        let f = true;\n        for (ty = y; ty <= ch; ty++) {\n          if (ty !== ch) {\n            for (\n              tx = x;\n              tx < cw\n              && picture[indexer(tx, ty)] <= targetColor;\n              tx++\n            );\n            tx--;\n          } else {\n            tx = 0;\n          }\n\n          // この処理形態のせいで、うまく処理できなかったのが2つ続く……\n          if (ox === undefined) {\n            ox = tx;\n          }\n\n          if (ox > tx) {\n            // 「不合格が出なければ記録する」ために、\n            // 「不合格ならtrue」を返すようにする\n            if (!rectangleMatrix[indexerZ(ox, ty - 1)].some((e) => x > e.x && y > e.y)) {\n              rectangleMatrix[indexerZ(ox, ty - 1)].push(new Vector2D(x, y));\n            }\n            ox = tx;\n          }\n\n          if (tx < x) {\n            f = false;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  const counter = new Uint8Array(cw * ch);\n  counter.fill(0);\n  for (let i = 0; i < rectangleMatrix.length; i++) {\n    const el = rectangleMatrix[i];\n    el?.forEach((v) => {\n      const ex = i % cw, ey = Math.floor(i / cw);\n      let f = false; // 未描画のエリアがあればtrue。falseの限りチェック\n      let f2 = false; // 自分の色が描画エリアにあればtrue\n      for (let ty = v.y; ty <= ey; ty++) {\n        for (let tx = v.x; tx <= ex; tx++) {\n          f = f || (counter[indexerZ(tx, ty)] === 0);\n          f2 = f2 || (picture[indexer(tx, ty)] === targetColor);\n        }\n      }\n\n      if (f && f2) {\n        drawCodes.push(v.x, v.y, ex - v.x + 1, ey - v.y + 1);\n        for (let ty = v.y; ty <= ey; ty++) {\n          for (let tx = v.x; tx <= ex; tx++) {\n            counter[indexerZ(tx, ty)] = 1;\n          }\n        }\n      }\n    });\n  }\n\n  return Uint32Array.from(drawCodes);\n}\n\nfunction makeIndexer(width: number, height: number, offsetX: number, offsetY: number) {\n  return (x: number, y: number) => {\n    return (offsetY + y) * width + (offsetX + x);\n  }\n}"],"names":["_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","Vector2D","x","y","this","ConvertedData","convertedData","index","layer","color","buffer","Results","progress","working","result","undefined","getTransfer","ctx","self","convertLayer","picture","w","h","cw","ch","offsetX","offsetY","targetColor","indexer","makeIndexer","indexerZ","rectangleMatrix","Array","drawCodes","tx","ty","ox","some","e","push","counter","Uint8Array","fill","el","forEach","v","ex","ey","Math","floor","f","f2","Uint32Array","from","width","height","addEventListener","evt","d","data","vCount","pictureHeight","cropHeight","hCount","pictureWidth","cropWidth","phase","colorSet","pic","pictureData","map","orderTable","postMessage","l","picIndex","indexOf","drawFlagTable"],"sourceRoot":""}